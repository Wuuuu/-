## 浏览器跨域
- 什么是跨域
- 为什么会跨域
- 为什么有跨域限制
- 怎么解决跨域

跨域问题的来源是浏览器为了**请求安全**而引入的基于**同源策略**的安全特性。当页面和请求的**协议**、**主机名**或**端口**不同时，浏览器判定两者不同源，即为跨域请求。需要注意的是跨域是**浏览器的限制**，服务端并不受此影响。当产生跨域时，我们可以通过**JSONP**、**CORS**、**postMessage**等方式解决。


### 1. 跨域问题的来源

跨域问题的来源是浏览器为了**请求安全**而引入的基于**同源策略**的安全特性。同源策略是浏览器一个非常重要的安全策略，基于这个策略可以限制非同源的内容与当前页面进行交互，从而减少页面被攻击的可能性。

当页面请求的**协议**、**主机名**或**端口**不同时，浏览器判定两者不同源，从而产生跨域。需要注意的是跨域是**浏览器的限制**，而实际请求已经正常发出和响应了。


### 2.如何判断跨域

只有当**协议**、**主机名**或**端口**都相同时，浏览器才判定两者的同源关系，否则即为跨域。

### 3.常见的解决方案

前端常见的跨域解决方案有CORS、反向代理、JSONP等。 

#### 3.1 CORS(Cross-Origin Resource Sharing)

CORS是目前最为广泛的解决跨域问题的方案。方案依赖服务端/后端在响应头中添加`Access-Control-Allow-*`头，告知浏览器端通过此请求。

#### 具体实现方式
CORS将请求分为**简单请求**和**需预检请求**，不同场景有不同行为：

#### 简单请求

不会触发预检请求的成为简单请求。当请求满足一下条件时就是一个简单请求：
- 请求方法 `GET`、`HEAD`、`POST`
- 请求头 `Accept`、`Accept-Language`、`Content-Language`、`Content-Type`。

#### 需预检请求
当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个**OPTIONS**请求，通过服务端返回的`Access-Control-Allow-*`判断请求是否被允许。

#### 3.2 反向代理
反向代理只需要服务端/后端支持，几乎不涉及前端改动，只用切换接口即可。

#### 具体实现方式
反向代理的实现方式为在页面同域下配置一套反向代理服务，页面请求同域的服务端，服务端请求上游的实际的服务端，之后将结果返回给前端。

#### 3.3 JSONP
JSONP 是一个相对老的跨域解决方案。主要利用了浏览器加载JavaScript资源文件时不受同源策略的限制而实现跨域获取数据。

JSONP需要服务端和前端配合实现。

#### 具体实现方式
JSONP的原理是利用了浏览器加载JavaScript资源文件时不受同源策略的限制而实现的。具体流程如下：
1. 全局注册一个函数，例如：`window.getData = res => console.log(res)`。
2. 构造一个请求URL, 例如：`https://test-jsonp.com/api/v1/usersInfo`。
3. 生成一个`script`标签并把`src`设为上一步的请求URL并插入到文档中，如`<script src="https://test-jsonp.com/api/v1/usersInfo"/>`
4. 服务端构造一个JavaScript函数调用表达式并返回，例如：`getData({xxx})`。
5. 浏览器加载并执行以上代码，输出{xxx}

#### 非常规方式
- postMessage
  - 即在两个origin下分别部署一套页面A与B，A页面通过`iframe`加载B页面并监听消息，B页面发送消息。
- window.name
  - 主要利用了`window.name`页面跳转不改变的特性实现跨域，即`iframe`加载一个跨域页面，设置`window.name`,并跳转到同域页面，可以通过`getContentWindow.name`拿到跨域页面的数据。
- document.domain
  - 可将相同一级域名下的子域名页面的`document.domain`
  - 可将同域不同端口的`document.domain`设置为同域名实现跨域